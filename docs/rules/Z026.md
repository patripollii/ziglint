---
rule: Z026
title: Empty catch block suppresses errors
enabled: true
---

# Z026: Empty catch block suppresses errors

Detects empty `catch {}` blocks that silently discard errors.

## Examples

### Bad

```zig
// expect: Z026
fn process() void {
    const result = riskyOperation() catch {};
    _ = result;
}
```

```zig
// expect: Z026
fn load() void {
    const data = readFile() catch |_| {};
    _ = data;
}
```

### Good

Handle the error explicitly:

```zig
fn process() void {
    const result = riskyOperation() catch |err| {
        log.warn("operation failed: {}", .{err});
        return;
    };
    use(result);
}
```

Or propagate it:

```zig
fn process() !void {
    const result = try riskyOperation();
    use(result);
}
```

Empty catches in `defer`/`errdefer` are allowed for cleanup:

```zig
fn process() !void {
    const file = try openFile();
    defer file.close() catch {};  // OK in defer
    // ...
}
```

Using `@panic` or `unreachable` is allowed:

```zig
const result = operation() catch @panic("unexpected");
const other = mustSucceed() catch unreachable;
```

## Rationale

Empty catch blocks hide errors, making debugging difficult. If an operation can fail, you should either handle the error, propagate it, or explicitly document why ignoring it is safe. Silent error suppression is a common source of hard-to-find bugs.
