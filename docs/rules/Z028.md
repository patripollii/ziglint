---
rule: Z028
title: Inline import
enabled: true
---

# Z028: Inline import

Detects `@import` calls that are not assigned to a top-level `const`. Imports should be declared at the top of the file, not inline in expressions.

## Examples

### Bad

```zig
// expect: Z028
// expect: Z028
const builtin = @import("builtin");
const Backend = switch (builtin.os.tag) {
    .linux => @import("linux.zig"),
    .macos => @import("macos.zig"),
    else => @compileError("unsupported"),
};
```

```zig
// expect: Z028
fn foo() void {
    const x = @import("bar.zig").baz;
    _ = x;
}
```

```zig
// expect: Z028
pub fn main() void {
    const std = @import("std");
    _ = std;
}
```

### Good

Assign imports to top-level constants:

```zig
const builtin = @import("builtin");
const linux = @import("linux.zig");
const macos = @import("macos.zig");

const Backend = switch (builtin.os.tag) {
    .linux => linux,
    .macos => macos,
    else => @compileError("unsupported"),
};
```

Field access on imports is allowed:

```zig
const Rule = @import("rules.zig").Rule;
```

Imports in test blocks are allowed:

```zig
test "example" {
    const testing = @import("testing.zig");
    testing.check();
}
```

Discard imports for pulling in tests are allowed:

```zig
test {
    _ = @import("other.zig");
}
```

## Rationale

Inline imports make code harder to read and maintain:

1. **Discoverability**: All imports at the top of a file make dependencies immediately visible
2. **Consistency**: Standard Zig style places imports at the top
3. **Deduplication**: Top-level imports naturally prevent duplicate imports of the same module
4. **Tooling**: Static analysis tools work better with predictable import locations
